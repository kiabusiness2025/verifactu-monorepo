datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  USER
  SUPPORT
  ADMIN
}

enum SubscriptionStatus {
  NONE
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
}

enum AuditAction {
  ADMIN_LOGIN
  ADMIN_LOGOUT
  IMPERSONATION_START
  IMPERSONATION_STOP
  USER_VIEW
  COMPANY_VIEW
  WEBHOOK_RETRY
  EMAIL_RETRY
  USER_BLOCK
  USER_UNBLOCK
  EMAIL_SEND
}

enum WebhookProvider {
  STRIPE
  RESEND
  AEAT
}

enum WebhookStatus {
  RECEIVED
  PROCESSING
  PROCESSED
  FAILED
  IGNORED
}

enum EmailStatus {
  QUEUED
  SENT
  DELIVERED
  BOUNCED
  COMPLAINED
  FAILED
}

enum EmailProvider {
  RESEND
  GMAIL
}

enum AuthProvider {
  FIREBASE
  GOOGLE
}

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  image          String?
  emailVerified  DateTime? // Required by NextAuth PrismaAdapter
  role           UserRole  @default(USER)
  
  // Authentication source
  authProvider   AuthProvider? // FIREBASE for client app, GOOGLE for admin
  authSubject    String?       @unique // Firebase UID or Google sub

  // Support actions
  isBlocked      Boolean   @default(false)
  blockedAt      DateTime?
  blockedReason  String?

  companiesOwned   Company[] @relation("CompanyOwner")
  memberships      CompanyMember[]

  subscriptions    Subscription[]
  auditActor       AuditLog[] @relation("AuditActor")
  auditTarget      AuditLog[] @relation("AuditTargetUser")

  // Operations
  webhookEvents    WebhookEvent[]
  emailEvents      EmailEvent[]

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Company {
  id          String @id @default(cuid())
  // Operations
  webhookEvents WebhookEvent[]
  emailEvents   EmailEvent[]

  name        String
  taxId       String? @unique  // NIF/CIF si aplica
  ownerUserId String
  owner       User   @relation("CompanyOwner", fields: [ownerUserId], references: [id])

  members       CompanyMember[]
  subscriptions Subscription[]
  auditLogs     AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerUserId])
}

model CompanyMember {
  id        String @id @default(cuid())
  companyId String
  userId    String
  role      String @default("MEMBER") // simple por ahora

  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([companyId, userId])
  @@index([userId])
  @@index([companyId])
}

model Subscription {
  id                String @id @default(cuid())
  userId            String?
  companyId         String?
  status            SubscriptionStatus @default(NONE)

  stripeCustomerId  String?
  stripeSubscriptionId String?
  stripePriceId     String?

  currentPeriodEnd  DateTime?
  cancelAtPeriodEnd Boolean @default(false)

  user    User?    @relation(fields: [userId], references: [id])
  company Company? @relation(fields: [companyId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([companyId])
  @@index([userId])
}

model AuditLog {
  id              String @id @default(cuid())
  action          AuditAction
  actorUserId     String
  targetUserId    String?
  targetCompanyId String?
  metadata        Json?

  actorUser     User     @relation("AuditActor", fields: [actorUserId], references: [id])
  targetUser    User?    @relation("AuditTargetUser", fields: [targetUserId], references: [id])
  targetCompany Company? @relation(fields: [targetCompanyId], references: [id])

  createdAt DateTime @default(now())

  @@index([actorUserId, createdAt])
  @@index([targetUserId, createdAt])
  @@index([targetCompanyId, createdAt])
}

//
// Operations Center - Webhooks & Emails
//
model WebhookEvent {
  id           String          @id @default(cuid())
  provider     WebhookProvider
  externalId   String?         // Stripe event ID, etc.
  eventType    String
  status       WebhookStatus   @default(RECEIVED)

  payload      Json
  signatureOk  Boolean         @default(false)

  receivedAt   DateTime        @default(now())
  processedAt  DateTime?
  lastError    String?
  
  attempts     WebhookAttempt[]

  // Optional context
  companyId    String?
  userId       String?
  company      Company? @relation(fields: [companyId], references: [id])
  user         User?    @relation(fields: [userId], references: [id])

  @@index([provider, receivedAt])
  @@index([status, receivedAt])
  @@index([externalId])
}

model WebhookAttempt {
  id             String   @id @default(cuid())
  webhookEventId String
  attemptNumber  Int
  ok             Boolean  @default(false)
  error          String?
  startedAt      DateTime @default(now())
  finishedAt     DateTime?

  webhookEvent   WebhookEvent @relation(fields: [webhookEventId], references: [id], onDelete: Cascade)

  @@index([webhookEventId, attemptNumber])
}

model EmailEvent {
  id          String        @id @default(cuid())
  messageId   String?       @unique // Resend or Gmail message ID
  threadId    String?       // Gmail thread ID
  to          String
  fromEmail   String?       // Sender email (support@verifactu.business for Gmail)
  template    String?
  subject     String?
  status      EmailStatus   @default(QUEUED)
  provider    EmailProvider @default(RESEND)
  payload     Json?
  lastError   String?

  userId      String?
  companyId   String?
  user        User?    @relation(fields: [userId], references: [id])
  company     Company? @relation(fields: [companyId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, createdAt])
  @@index([userId, createdAt])
  @@index([companyId, createdAt])
  @@index([provider, createdAt])
}

//
// NextAuth (PrismaAdapter)
//
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
