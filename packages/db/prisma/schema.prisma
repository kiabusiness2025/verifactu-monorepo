datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  USER
  SUPPORT
  ADMIN
}

enum SubscriptionStatus {
  NONE
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
}

enum AuditAction {
  ADMIN_LOGIN
  ADMIN_LOGOUT
  IMPERSONATION_START
  IMPERSONATION_STOP
  SUPPORT_SESSION_START
  SUPPORT_SESSION_END
  SUPPORT_IMPERSONATE
  TENANT_SUSPEND
  TENANT_ACTIVATE
  USER_VIEW
  COMPANY_VIEW
  WEBHOOK_RETRY
  EMAIL_RETRY
  USER_BLOCK
  USER_UNBLOCK
  EMAIL_SEND
}

enum WebhookProvider {
  STRIPE
  RESEND
  AEAT
}

enum WebhookStatus {
  RECEIVED
  PROCESSING
  PROCESSED
  FAILED
  IGNORED
}

enum EmailStatus {
  QUEUED
  SENT
  DELIVERED
  BOUNCED
  COMPLAINED
  FAILED
}

enum EmailProvider {
  RESEND
  GMAIL
}

enum AuthProvider {
  FIREBASE
  GOOGLE
}

// ==================== CORE USER & AUTH ====================

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  image          String?
  emailVerified  DateTime? // Required by NextAuth PrismaAdapter
  role           UserRole  @default(USER)
  
  // Authentication source
  authProvider   AuthProvider? // FIREBASE for client app, GOOGLE for admin
  authSubject    String?       @unique // Firebase UID or Google sub

  // Support actions
  isBlocked      Boolean   @default(false)
  blockedAt      DateTime?
  blockedReason  String?

  // Admin/Multi-tenant relations
  companiesOwned   Company[] @relation("CompanyOwner")
  memberships      CompanyMember[]
  subscriptions    Subscription[]
  auditActor       AuditLog[] @relation("AuditActor")
  auditTarget      AuditLog[] @relation("AuditTargetUser")
  supportSessionsAsUser  SupportSession[] @relation("SupportSessionUser")
  supportSessionsAsAdmin SupportSession[] @relation("SupportSessionAdmin")
  webhookEvents    WebhookEvent[]
  emailEvents      EmailEvent[]

  // Client app relations
  tenantMemberships  Membership[]
  tenantPreferences  UserPreference?
  onboarding         UserOnboarding?
  invoicesCreatedBy  Invoice[]           @relation("CreatedByUser")
  isaakConversations IsaakConversation[]

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ==================== ADMIN: COMPANIES & SUBSCRIPTIONS ====================

model Company {
  id          String @id @default(cuid())
  name        String
  taxId       String? @unique  // NIF/CIF si aplica
  ownerUserId String
  owner       User   @relation("CompanyOwner", fields: [ownerUserId], references: [id])

  members       CompanyMember[]
  subscriptions Subscription[]
  auditLogs     AuditLog[]
  webhookEvents WebhookEvent[]
  emailEvents   EmailEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerUserId])
}

model CompanyMember {
  id        String @id @default(cuid())
  companyId String
  userId    String
  role      String @default("MEMBER")

  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([companyId, userId])
  @@index([userId])
  @@index([companyId])
}

model Subscription {
  id                String @id @default(cuid())
  userId            String?
  companyId         String?
  status            SubscriptionStatus @default(NONE)

  stripeCustomerId  String?
  stripeSubscriptionId String?
  stripePriceId     String?

  currentPeriodEnd  DateTime?
  cancelAtPeriodEnd Boolean @default(false)

  user    User?    @relation(fields: [userId], references: [id])
  company Company? @relation(fields: [companyId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([companyId])
  @@index([userId])
}

model AuditLog {
  id              String @id @default(cuid())
  action          AuditAction
  actorUserId     String
  targetUserId    String?
  targetCompanyId String?
  metadata        Json?

  actorUser     User     @relation("AuditActor", fields: [actorUserId], references: [id])
  targetUser    User?    @relation("AuditTargetUser", fields: [targetUserId], references: [id])
  targetCompany Company? @relation(fields: [targetCompanyId], references: [id])

  createdAt DateTime @default(now())

  @@index([actorUserId, createdAt])
  @@index([targetUserId, createdAt])
  @@index([targetCompanyId, createdAt])
}

// ==================== OPERATIONS: ERROR MONITOR ====================

model ErrorEvent {
  id          String   @id @default(cuid())
  source      String?
  type        String
  url         String
  details     Json?
  userAgent   String?
  viewport    Json?
  performance Json?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@index([type, createdAt])
  @@index([source, createdAt])
}

// ==================== OPERATIONS: WEBHOOKS & EMAILS ====================

model WebhookEvent {
  id           String          @id @default(cuid())
  provider     WebhookProvider
  externalId   String?
  eventType    String
  status       WebhookStatus   @default(RECEIVED)

  payload      Json
  signatureOk  Boolean         @default(false)

  receivedAt   DateTime        @default(now())
  processedAt  DateTime?
  lastError    String?
  
  attempts     WebhookAttempt[]

  companyId    String?
  userId       String?
  company      Company? @relation(fields: [companyId], references: [id])
  user         User?    @relation(fields: [userId], references: [id])

  @@index([provider, receivedAt])
  @@index([status, receivedAt])
  @@index([externalId])
}

model WebhookAttempt {
  id             String   @id @default(cuid())
  webhookEventId String
  attemptNumber  Int
  ok             Boolean  @default(false)
  error          String?
  startedAt      DateTime @default(now())
  finishedAt     DateTime?

  webhookEvent   WebhookEvent @relation(fields: [webhookEventId], references: [id], onDelete: Cascade)

  @@index([webhookEventId, attemptNumber])
}

model EmailEvent {
  id          String        @id @default(cuid())
  messageId   String?       @unique
  threadId    String?
  to          String
  fromEmail   String?
  template    String?
  subject     String?
  status      EmailStatus   @default(QUEUED)
  provider    EmailProvider @default(RESEND)
  payload     Json?
  lastError   String?

  userId      String?
  companyId   String?
  user        User?    @relation(fields: [userId], references: [id])
  company     Company? @relation(fields: [companyId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status, createdAt])
  @@index([userId, createdAt])
  @@index([companyId, createdAt])
  @@index([provider, createdAt])
}

// ==================== NEXTAUTH (PRISMA ADAPTER) ====================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ==================== CLIENT APP: TENANTS & INVOICING ====================

model Tenant {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name      String
  legalName String?  @map("legal_name")
  nif       String?
  isDemo    Boolean  @default(false) @map("is_demo")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  users               Membership[]
  userPref            UserPreference[]
  tenantSubscriptions TenantSubscription[]
  profile             TenantProfile?
  invoices            Invoice[]
  invoiceLines        InvoiceLine[]
  payments            Payment[]
  customers           Customer[]
  suppliers           Supplier[]
  articles            Article[]
  expenses            ExpenseRecord[]
  isaakConversations  IsaakConversation[]
  demoOnboardings     UserOnboarding[]
  supportSessions     SupportSession[]

  @@map("tenants")
}

model TenantProfile {
  tenantId          String    @id @map("tenant_id") @db.Uuid
  tenant            Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  source            String    @default("manual")
  sourceId          String?   @map("source_id")
  einformaLastSyncAt DateTime? @map("einforma_last_sync_at") @db.Timestamptz
  einformaTaxIdVerified Boolean? @map("einforma_tax_id_verified")
  einformaRaw       Json?     @map("einforma_raw")
  cnae              String?
  cnaeCode          String?   @map("cnae_code")
  cnaeText          String?   @map("cnae_text")
  legalForm         String?   @map("legal_form")
  status            String?
  website           String?
  capitalSocial     Decimal?  @map("capital_social")
  incorporationDate DateTime? @map("incorporation_date") @db.Date
  address           String?
  postalCode        String?   @map("postal_code")
  city              String?
  province          String?
  country           String?
  representative    String?
  updatedAt         DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  @@map("tenant_profiles")
}

model EinformaLookup {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  queryType  String   @map("query_type")
  queryValue String   @map("query_value")
  raw        Json
  normalized Json
  expiresAt  DateTime @map("expires_at") @db.Timestamptz
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([queryType, queryValue])
  @@index([expiresAt])
  @@map("einforma_lookups")
}

model Membership {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId  String   @map("tenant_id") @db.Uuid
  userId    String   @map("user_id")
  role      String   @default("member")
  status    String   @default("active")
  invitedBy String?  @map("invited_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
  @@index([userId])
  @@index([tenantId])
  @@map("memberships")
}

model UserPreference {
  userId            String   @id @map("user_id")
  preferredTenantId String?  @map("preferred_tenant_id") @db.Uuid
  updatedAt         DateTime @default(now()) @map("updated_at") @db.Timestamptz

  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  preferredTenant Tenant? @relation(fields: [preferredTenantId], references: [id], onDelete: SetNull)

  @@map("user_preferences")
}

model UserOnboarding {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @unique @map("user_id")
  demoTenantId String?  @map("demo_tenant_id") @db.Uuid
  completedAt  DateTime? @map("completed_at") @db.Timestamptz
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz

  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  demoTenant Tenant? @relation(fields: [demoTenantId], references: [id], onDelete: SetNull)

  @@index([demoTenantId])
  @@map("user_onboarding")
}

model Plan {
  id                  Int      @id @default(autoincrement())
  code                String   @unique
  name                String
  fixedMonthly        Decimal  @default(0) @map("fixed_monthly")
  variableRate        Decimal  @default(0) @map("variable_rate")
  maxInvoicesPerMonth Int?     @map("max_invoices_per_month")
  maxRevenuePerMonth  Decimal? @map("max_revenue_per_month")
  createdAt           DateTime @default(now()) @map("created_at") @db.Timestamptz

  subscriptions TenantSubscription[]

  @@map("plans")
}

model TenantSubscription {
  id                 String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId           String    @map("tenant_id") @db.Uuid
  planId             Int       @map("plan_id")
  status             String    @default("active")
  trialEndsAt        DateTime? @map("trial_ends_at") @db.Timestamptz
  currentPeriodStart DateTime? @map("current_period_start") @db.Timestamptz
  currentPeriodEnd   DateTime? @map("current_period_end") @db.Timestamptz
  stripeCustomerId     String?  @map("stripe_customer_id")
  stripeSubscriptionId String?  @map("stripe_subscription_id")
  stripePriceId        String?  @map("stripe_price_id")
  stripeStatus         String?  @map("stripe_status")
  cancelAtPeriodEnd    Boolean? @default(false) @map("cancel_at_period_end")
  updatedAt           DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  plan   Plan   @relation(fields: [planId], references: [id])

  @@index([tenantId, status])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("tenant_subscriptions")
}

model SupportSession {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  tenantId  String   @map("tenant_id") @db.Uuid
  userId    String   @map("user_id")
  adminId   String   @map("admin_id")

  reason    String
  startedAt DateTime @default(now()) @map("started_at") @db.Timestamptz
  endedAt   DateTime? @map("ended_at") @db.Timestamptz

  ip        String?  @map("ip")
  userAgent String?  @map("user_agent")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation("SupportSessionUser", fields: [userId], references: [id], onDelete: Cascade)
  admin  User   @relation("SupportSessionAdmin", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([tenantId, startedAt])
  @@index([userId, startedAt])
  @@index([adminId, startedAt])
  @@map("support_sessions")
}

model Invoice {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId        String   @map("tenant_id") @db.Uuid
  customerId      String?  @map("customer_id") @db.Uuid
  number          String
  issueDate       DateTime @map("issue_date") @db.Date
  customerName    String   @map("customer_name")
  customerNif     String?  @map("customer_nif")
  currency        String   @default("EUR") @db.Char(3)
  amountGross     Decimal  @map("amount_gross")
  amountTax       Decimal  @map("amount_tax")
  amountNet       Decimal  @map("amount_net")
  status          String   @default("draft")
  notes           String?
  verifactuStatus String?  @map("verifactu_status")
  verifactuQr     String?  @map("verifactu_qr")
  verifactuHash   String?  @map("verifactu_hash")
  createdBy       String   @map("created_by")
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer      Customer?     @relation(fields: [customerId], references: [id], onDelete: SetNull)
  createdByUser User          @relation("CreatedByUser", fields: [createdBy], references: [id])
  payments      Payment[]
  lines         InvoiceLine[]

  @@index([tenantId])
  @@index([customerId])
  @@map("invoices")
}

model Payment {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  invoiceId String   @map("invoice_id") @db.Uuid
  tenantId  String   @map("tenant_id") @db.Uuid
  amount    Decimal
  method    String   @default("bank_transfer")
  reference String?
  paidAt    DateTime @map("paid_at") @db.Date
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@index([tenantId])
  @@map("payments")
}

model Customer {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId     String   @map("tenant_id") @db.Uuid
  name         String
  email        String?
  phone        String?
  nif          String?
  address      String?
  city         String?
  postalCode   String?  @map("postal_code")
  country      String?  @default("ES")
  paymentTerms String?  @map("payment_terms")
  notes        String?
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoices Invoice[]

  @@index([tenantId])
  @@index([nif])
  @@index([email])
  @@map("customers")
}

model Supplier {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId     String   @map("tenant_id") @db.Uuid
  name         String
  email        String?
  phone        String?
  nif          String?
  address      String?
  city         String?
  postalCode   String?  @map("postal_code")
  country      String?  @default("ES")
  accountCode  String?  @map("account_code")
  paymentTerms String?  @map("payment_terms")
  notes        String?
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant   Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  expenses ExpenseRecord[]

  @@index([tenantId])
  @@index([nif])
  @@index([email])
  @@map("suppliers")
}

model Article {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId    String   @map("tenant_id") @db.Uuid
  code        String
  name        String
  description String?
  category    String?
  unitPrice   Decimal  @map("unit_price")
  taxRate     Decimal  @default(0.21) @map("tax_rate")
  accountCode String?  @map("account_code")
  unit        String   @default("ud")
  stock       Int?
  notes       String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoiceLines InvoiceLine[]

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([category])
  @@map("articles")
}

model InvoiceLine {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  invoiceId String   @map("invoice_id") @db.Uuid
  articleId String   @map("article_id") @db.Uuid
  tenantId  String   @map("tenant_id") @db.Uuid
  quantity  Decimal
  unitPrice Decimal  @map("unit_price")
  taxRate   Decimal  @default(0.21) @map("tax_rate")
  discount  Decimal? @default(0)
  lineTotal Decimal  @map("line_total")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  article Article @relation(fields: [articleId], references: [id])
  tenant  Tenant  @relation(fields: [tenantId], references: [id])

  @@index([invoiceId])
  @@index([articleId])
  @@map("invoice_lines")
}

model ExpenseRecord {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId    String   @map("tenant_id") @db.Uuid
  supplierId  String?  @map("supplier_id") @db.Uuid
  date        DateTime @map("date") @db.Date
  description String
  category    String
  amount      Decimal
  taxRate     Decimal  @default(0.21) @map("tax_rate")
  accountCode String?  @map("account_code")
  reference   String?
  notes       String?
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  supplier Supplier? @relation(fields: [supplierId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([supplierId])
  @@index([date])
  @@index([category])
  @@map("expense_records")
}

// ==================== ISAAK CONVERSATIONS ====================

model IsaakConversation {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId     String   @map("tenant_id") @db.Uuid
  userId       String   @map("user_id")
  title        String?
  context      String?
  summary      String?
  messageCount Int      @default(0) @map("message_count")
  lastActivity DateTime @map("last_activity") @db.Timestamptz
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  tenant   Tenant                       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user     User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages IsaakConversationMsg[]
  shares   IsaakConversationShare[]

  @@index([tenantId])
  @@index([userId])
  @@index([lastActivity])
  @@map("isaak_conversations")
}

model IsaakConversationMsg {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String   @map("conversation_id") @db.Uuid
  role           String
  content        String
  tokens         Int?
  metadata       Json?
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  conversation IsaakConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([role])
  @@index([createdAt])
  @@map("isaak_conversation_messages")
}

model IsaakConversationShare {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String    @map("conversation_id") @db.Uuid
  shareToken     String    @unique @map("share_token")
  passwordHash   String?   @map("password_hash")
  expiresAt      DateTime  @map("expires_at") @db.Timestamptz
  accessCount    Int       @default(0) @map("access_count")
  lastAccessedAt DateTime? @map("last_accessed_at") @db.Timestamptz
  createdBy      String    @map("created_by")
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz

  conversation IsaakConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([shareToken])
  @@index([conversationId])
  @@index([expiresAt])
  @@map("isaak_conversation_shares")
}
